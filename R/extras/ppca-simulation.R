
# this simulation tests the "ppca.stan" program, ensuring that it returns principal component
# loadings vectors that are comparable with the ones generated by regular principal components analysis
# via prcomp()

# setup -------------------------------------------------------------------

library("here")
library("cmdstanr")
library("MASS") # for generating multivariate normal data
library("purrr")
library("ggplot2")
library("tibble")
library("tidyr")
library("trialr") # for generating correlation matrices

options(mc.cores = parallel::detectCores())

# read --------------------------------------------------------------------

ppca_code <- readLines(here("R/stan/ppca.stan"))

# simulation --------------------------------------------------------------

# simulation parameters:

n_observations <- 100
n_variables <- 9
n_iterations <- 100

# compile stan model:

ppca_compiled <- cmdstan_model(stan_file = write_stan_file(ppca_code))

simulation_output <- replicate(n_iterations, {
  # simulate mean vector:
  means <- rep(0, n_variables)
  # simulate sigma:
  rho <- trialr::rlkjcorr(1, n_variables)
  variances <- diag(runif(n_variables, 0, 50))
  sigma <- variances %*% rho %*% variances
  # simulate data:
  data <- mvrnorm(n = n_observations, mu = means, Sigma = sigma)
  # build cmdstan input list:
  ppca_data <- list(
    N = n_observations,
    D = n_variables,
    M = n_variables,
    y = data
  )
  # fit pca:
  pca_simulated <- prcomp(data)
  # fit ppca:
  ppca_simulated <- ppca_compiled$variational(data = ppca_data, algorithm = "meanfield")
  # extract draws:
  ppca_draws <- ppca_simulated$draws("w") |>
    apply(2, mean) |>
    matrix(nrow = n_variables, ncol = n_variables) |>
    # orthonormalize:
    svd() |>
    with(u)
  # calculate rmse:
  map_dbl(
    seq(n_variables),
    ~ cor(ppca_draws[,.x], pca_simulated$rotation[,.x])
  ) |>
    set_names(paste0("corr_pc", seq(n_variables)))
})

# plot output -------------------------------------------------------------

simulation_output_tibble <- t(simulation_output) |>
  as_tibble()

simulation_output_tibble |>
  pivot_longer(everything()) |>
  ggplot(aes(name, abs(value))) +
  geom_boxplot()

# compare to null hypothesis: correlation of two uniformly distributed random vectors on [-1, 1]

null_hypothesis <- replicate(n_iterations, cor(runif(n_variables, -1, 1), runif(n_variables, -1, 1)))

quantile(abs(null_hypothesis), c(0.025, 0.5, 0.975))
quantile(abs(simulation_output_tibble$corr_pc1), c(0.025, 0.5, 0.975))
